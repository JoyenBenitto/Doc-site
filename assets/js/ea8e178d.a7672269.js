"use strict";(self.webpackChunkdoc_site=self.webpackChunkdoc_site||[]).push([[7210],{6446:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>r,toc:()=>l});var i=n(5893),o=n(1151);const a={slug:"Unique_index-Part-2",title:"Unique index calculation part-2",sidebar_position:7,authors:{name:"Joyen Benitto",title:"Unique index calculation part-2",url:"https://github.com/JoyenBenitto",image_url:"https://avatars.githubusercontent.com/u/75515758?v=4"},tags:["cuda","index"]},s=void 0,r={id:"CUDA101/Unique_index_Calculation_p2",title:"Unique index calculation part-2",description:"Example1: Building up from the previous page assume that there is a grid with 4 blocks 2 in x-dimension and 2 in y-dimension. Each of these blocks have 4 threads in x-dimension only. Write a CUDA program to parse through each element.",source:"@site/docs/CUDA101/Unique_index_Calculation_p2.md",sourceDirName:"CUDA101",slug:"/CUDA101/Unique_index-Part-2",permalink:"/Doc-site/docs/CUDA101/Unique_index-Part-2",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/CUDA101/Unique_index_Calculation_p2.md",tags:[{label:"cuda",permalink:"/Doc-site/docs/tags/cuda"},{label:"index",permalink:"/Doc-site/docs/tags/index"}],version:"current",sidebarPosition:7,frontMatter:{slug:"Unique_index-Part-2",title:"Unique index calculation part-2",sidebar_position:7,authors:{name:"Joyen Benitto",title:"Unique index calculation part-2",url:"https://github.com/JoyenBenitto",image_url:"https://avatars.githubusercontent.com/u/75515758?v=4"},tags:["cuda","index"]},sidebar:"tutorialSidebar",previous:{title:"Unique index calculation part-1",permalink:"/Doc-site/docs/CUDA101/Unique_index-Part-1"},next:{title:"Memory transfer between host and device",permalink:"/Doc-site/docs/CUDA101/Memory-transfer-between-host-and-device"}},c={},l=[];function d(e){const t={code:"code",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Example1:"})," Building up from the previous page assume that there is a grid with 4 blocks 2 in x-dimension and 2 in y-dimension. Each of these blocks have 4 threads in x-dimension only. Write a CUDA program to parse through each element."]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"The previous offset won't work as it will return the same 8 elements from the x-dimension."}),"\n",(0,i.jsx)(t.li,{children:"Now we will need a block offset along with the thread offset."}),"\n"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"num_of_threads_row = gridDim.x * blockDim.x\nnum_of_threads_thread_block = blockDim.x\n\n\nrow_offset = num_of_threads_in_block * blockIdx.y\nblock_offset = number_of_threads_in_block * blockIdx.X\nindex = row_offset + block_offset + tid\n"})}),"\n",(0,i.jsx)(t.p,{children:"The final equation of the above can be shown below as follows"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"gid = gridDim.x*blockDim.x*blockIdx.y + \n\t\tblcokIdx.x* blockDim.x + \n\t\tthreadIdx.x\n"})})]})}function u(e={}){const{wrapper:t}={...(0,o.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>r,a:()=>s});var i=n(7294);const o={},a=i.createContext(o);function s(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);